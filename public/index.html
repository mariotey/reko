<!DOCTYPE html>
<html>
<head>
    <title>Survey Data Visualizer</title>
    <meta charset="UTF-8">
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #ddd;
            text-align: left;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .processing-dropdown {
            margin-bottom: 10px;
        }
        /* Styling for the container div */
        #container {
            display: flex;
        }
        /* Styling for the chart canvas */
        #chartContainer {
            display: flex; /* Use Flexbox for layout */
            flex-wrap: wrap; /* Allow wrapping if there are too many charts */
            justify-content: space-around; /* Evenly space the charts */
            align-items: center; /* Align charts vertically */
        }
        #chartContainer canvas {
            margin: 10px; /* Add some margin around each canvas */
        }
        /* Styling for the new data summary div */
        #newDataSummary {
            padding: 10px;
            width: 15%;
            margin-top: 100px;
            margin-right: 1100px; /* Adjust the margin as needed */
        }
        #dataDisplay {
            height: 400px; /* Fixed height */
            overflow: auto; /* Enables scrolling */
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@0.7.0"></script>
</head>
<body>
    <p>
        <text>Upload your excel file here</text>
        <form id="uploadForm">
            <input type="file" name="file" accept=".xlsx, .xls" />
        </form>
    </p>

    <p>
        <div style="padding-top: 30px;">
            <text>After you've chosen your file, add some general metrics that your survey is measuring</text>
            <br><input type="text" id="metricNameInput" placeholder="Metric Name">
            <button id="addMetricButton">Add Metric</button>
        </div>
        <div id="metricList"></div>
    </p>
    <button type="button" id="uploadButton">Upload and Display Data</button>
    <div id="dataDisplay"></div>
    <button type="button" id="processButton">Process Data</button>
    <!-- Original Data Summary Div -->
    <div id="dataSummary" style="margin-left: 20px;"></div>

    <!-- Add dropdowns for data and chart type selection -->

    <div id="metricsCheckboxList">
        <!-- Checkboxes will be added here dynamically -->
    </div>

    <select id="chartTypeDropdown">`
        <option value="bar">Bar Chart</option>
        <option value="line">Line Chart</option>
        <option value="pie">Pie Chart</option>
        <!-- Add more chart types as needed -->
    </select>
    <button id="renderChartButton">Render Chart</button>

    <!-- Container div for chart and new data summary -->
    <div id="container">
        <!-- Chart canvas div -->
        <div id="chartContainer">
            <!-- Canvas for Chart.js -->
            <canvas id="myChart" width="550" height="550"></canvas>
        </div>
        <!-- New Data Summary Div (initially hidden) -->
        <div id="newDataSummary" style="display: none;"></div>
    </div>
    <script>
        function displayDataAsTable(dataSummary) {
            const table = document.createElement('table');
            for (const key in dataSummary) {
                const headerRow = document.createElement('tr');
                const header = document.createElement('th');
                header.textContent = key;
                headerRow.appendChild(header);
                table.appendChild(headerRow);

                const data = dataSummary[key];
                for (const item in data) {
                    const row = document.createElement('tr');
                    const cell = document.createElement('td');
                    cell.textContent = `${item}: ${data[item]}`;
                    row.appendChild(cell);
                    table.appendChild(row);
                }
            }

            document.getElementById('dataSummary').innerHTML = ''; // Clear existing content
            document.getElementById('dataSummary').appendChild(table); // Append the new table
        }

        // Function to populate the data selection dropdown
        function populateDataSelectionDropdown(dataSummary) {
            const dropdown = document.getElementById('dataSelectionDropdown');
            Object.keys(dataSummary).forEach(key => {
                const option = document.createElement('option');
                //const lowercaseKey = key; // Convert to lowercase for consistency
                option.value = key; // Use lowercase as the value
                option.textContent = key; // Display original capitalization
                dropdown.appendChild(option);
            });
        }

        // Declare selectedKey variable outside of the event listener to make it accessible
        let selectedKey = '';

        // Function to display the new data summary
        function displayNewDataSummary(newDataSummary) {
            const newDataSummaryDiv = document.getElementById('newDataSummary');
            newDataSummaryDiv.innerHTML = ''; // Clear existing content

            // Create a table for the new data summary
            const table = document.createElement('table');
            for (const key in newDataSummary) {
                const headerRow = document.createElement('tr');
                const header = document.createElement('th');
                header.textContent = key;
                headerRow.appendChild(header);
                table.appendChild(headerRow);

                const count = newDataSummary[key]; // Get the count
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.textContent = `Count: ${count}`; // Display the count
                row.appendChild(cell);
                table.appendChild(row);
            }

            newDataSummaryDiv.appendChild(table); // Append the new data summary table
            newDataSummaryDiv.style.display = 'block'; // Display the new data summary div
        }
        // Function to render the chart
        document.getElementById('renderChartButton').addEventListener('click', function() {
            selectedKey = document.getElementById('dataSelectionDropdown').value; // Update selectedKey
            const chartType = document.getElementById('chartTypeDropdown').value;
            const { labels, dataPoints } = transformDataForChart(processedData, selectedKey);

            // Get the selected metric name
            const selectedMetricName = selectedKey;

            console.log('Selected Metric Name:', selectedMetricName); // Add this line for debugging

            // Call the renderChart function with the selected metric name as the chart title
            renderChart(dataPoints, labels, chartType, selectedMetricName);

            // Debugging: Check if newDataSummary is correctly retrieved
            const newDataSummary = processedData[selectedKey];
            console.log('New Data Summary:', newDataSummary);

            // Generate and display the new data summary
            displayNewDataSummary(newDataSummary); // Use displayNewDataSummary for the new data summary
            displayDataAsTable(processedData); // Use displayDataAsTable for the original data summary
        });


        let myChart = null; // Global variable to store the chart instance

        function renderChart(canvasId, data, labels, chartType, metricName) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            // Create a new Chart instance
            new Chart(ctx, {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: metricName, // Use the metric name as the dataset label
                        data: data,
                        // Additional dataset styling options...
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: metricName // Set the chart title dynamically to the metric name
                        },
                        datalabels: {
                            display: true, // Set to true to display data labels
                            color: 'black',
                            align: 'end',
                            anchor: 'end',
                            formatter: function(value, context) {
                                return value; // Modify as needed
                            }
                        }
                    },
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true
                            }
                        }]
                    },
                    responsive: false,
                    /* Chart options */
                }
            });

            // Update the data summary
            updateDataSummary(selectedKey);
        }


        function updateDataSummary(selectedKey) {
            const dataSummaryDiv = document.getElementById('dataSummary');
            dataSummaryDiv.innerHTML = '';

            // Create a table to display the data summary
            const table = document.createElement('table');
            const headerRow = document.createElement('tr');
            const headerCell = document.createElement('th');
            headerCell.textContent = 'Data Summary';
            headerRow.appendChild(headerCell);
            table.appendChild(headerRow);

            // Get the data for the selected metric
            const data = processedData[selectedKey];
            for (const item in data) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.textContent = `${item}: ${data[item]}`;
                row.appendChild(cell);
                table.appendChild(row);
            }

            dataSummaryDiv.appendChild(table);

            // Display the data summary div
            dataSummaryDiv.style.display = 'block';
        }

        function transformDataForChart(dataSummary, key) {
            const dataObj = dataSummary[key];
            const labels = Object.keys(dataObj);
            const dataPoints = labels.map(label => dataObj[label]);
            return { labels, dataPoints };
        }

        let metrics = [];

        document.getElementById('addMetricButton').addEventListener('click', function() {
            const metricName = document.getElementById('metricNameInput').value.trim();
            if (metricName && !metrics.includes(metricName)) {
                metrics.push(metricName);
                updateMetricList();
                document.getElementById('metricNameInput').value = ''; // Clear input field
            }
        });

        function updateMetricList() {
            const metricListDiv = document.getElementById('metricList');
            metricListDiv.innerHTML = '';
            metrics.forEach(metric => {
                metricListDiv.innerHTML += `<div>${metric}</div>`;
            });
        }

        let tableData = {}; // Global variable to store the table data

        document.getElementById('uploadButton').addEventListener('click', function() {
            const formData = new FormData(document.getElementById('uploadForm'));
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                tableData = data; // Store the data in the global variable
                const table = createTable(data.headers, data.rows);
                document.getElementById('dataDisplay').innerHTML = '';
                document.getElementById('dataDisplay').appendChild(table);
            })
            .catch(error => {
                console.error('Error:', error);
            });
        });

        function createTable(headers, rows) {
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            // Create header row for column names
            const headerRow = document.createElement('tr');
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Create header row for metric dropdowns
            const metricDropdownRow = document.createElement('tr');
            headers.forEach(header => {
                const metricDropdownCell = document.createElement('th');
                // Use createDropdown function to create the metric dropdown
                const metricDropdown = createDropdown(metrics, 'metric-dropdown');
                metricDropdownCell.appendChild(metricDropdown);
                metricDropdownRow.appendChild(metricDropdownCell);
            });
            thead.appendChild(metricDropdownRow);

            // Header row for processing dropdowns
            const processingDropdownRow = document.createElement('tr');
            headers.forEach(header => {
                const processingDropdownCell = document.createElement('th');
                const processingDropdown = createDropdown(['Count', 'List'], 'processing-dropdown');
                processingDropdownCell.appendChild(processingDropdown);
                processingDropdownRow.appendChild(processingDropdownCell);
            });
            thead.appendChild(processingDropdownRow);

            // Create data rows
            rows.forEach(row => {
                const tr = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = row[header] || '';
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });

            table.appendChild(thead);
            table.appendChild(tbody);
            return table;
        }

        function createDropdown(options, className) {
            const dropdown = document.createElement('select');
            dropdown.className = className;
            // Add a default 'None' option
            const defaultOption = document.createElement('option');
            defaultOption.value = 'none';
            defaultOption.textContent = 'None';
            dropdown.appendChild(defaultOption);
            options.forEach(optionText => {
                const option = document.createElement('option');
                option.value = optionText;
                option.textContent = optionText; // Display original capitalization
                dropdown.appendChild(option);
            });
            return dropdown;
        }

        let processedData = {}; // Global variable to store processed data

        document.getElementById('processButton').addEventListener('click', function() {
            const selectedMetrics = Array.from(document.querySelectorAll('.metric-dropdown')).map(dropdown => dropdown.value);
            const preferences = Array.from(document.querySelectorAll('.processing-dropdown')).map(dropdown => dropdown.value);

            fetch('/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    data: tableData,
                    preferences: preferences,
                    selectedMetrics: selectedMetrics
                })
            })
            .then(response => response.json())
            .then(data => {
                processedData = data; // Store the processed data
                document.getElementById('dataSummary').innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';

                // Call the function to display data as a table
                displayDataAsTable(data);
                const metrics = Object.keys(processedData);
            populateMetricsCheckboxes(metrics); // Populate checkboxes with these metrics
            })
            .catch(error => console.error('Error:', error));
        });
    </script>

    <script>
    function populateMetricsCheckboxes(metrics) {
        const container = document.getElementById('metricsCheckboxList');
        container.innerHTML = ''; // Clear existing checkboxes

        metrics.forEach(metric => {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = metric;
            checkbox.value = metric;

            const label = document.createElement('label');
            label.htmlFor = metric;
            label.textContent = metric;

            container.appendChild(checkbox);
            container.appendChild(label);
        });
    }

    document.getElementById('renderChartButton').addEventListener('click', function() {
        // Clear the existing charts
        const chartContainer = document.getElementById('chartContainer');
        chartContainer.innerHTML = '';

        // Get selected metrics
        const selectedMetrics = Array.from(document.querySelectorAll('#metricsCheckboxList input[type="checkbox"]:checked')).map(checkbox => checkbox.value);

        // Create and render a chart for each selected metric
        selectedMetrics.forEach(metric => {
            // Create a new canvas for each chart
            const canvas = document.createElement('canvas');
            canvas.id = 'chart_' + metric;
            canvas.width = 400; // Set a fixed width
            canvas.height = 400; // Set a fixed height
            chartContainer.appendChild(canvas);

            // Get data for chart
            const { labels, dataPoints } = transformDataForChart(processedData, metric);

            // Render chart on the new canvas
            renderChart(canvas.id, dataPoints, labels, document.getElementById('chartTypeDropdown').value, metric);
        });

        // Display the data summary
        displayDataAsTable(processedData);
    });
    </script>

</body>
</html>